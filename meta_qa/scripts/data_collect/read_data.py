#!/usr/bin/env python3
"""
Read and visualize offline RL datasets.

This script reads HDF5 datasets generated by collect_data.py and provides:
- Dataset information and statistics
- Sample data inspection
- Trajectory visualization
- QA data display

Usage:
    # Basic info
    python -m meta_qa.scripts.data_collect.read_data --file outputs/offline_data/original_qa.h5
    
    # List available datasets
    python -m meta_qa.scripts.data_collect.read_data --list
    
    # Visualize trajectories
    python -m meta_qa.scripts.data_collect.read_data --file outputs/offline_data/original_qa.h5 --visualize
    
    # Show QA data
    python -m meta_qa.scripts.data_collect.read_data --file outputs/offline_data/original_qa.h5 --show_qa
    
    # Visualize specific episode
    python -m meta_qa.scripts.data_collect.read_data --file outputs/offline_data/original_qa.h5 --visualize --episode 0
"""

import os
import sys
import argparse
import json
import numpy as np
from typing import Dict, Any, List, Optional, Tuple

project_root = os.path.dirname(os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__)))))
sys.path.insert(0, project_root)

# Default output directory
DEFAULT_OUTPUT_DIR = os.path.join(project_root, "outputs", "offline_data")


class OfflineDataReader:
    """Reader for offline RL datasets."""
    
    def __init__(self, filepath: str):
        """
        Initialize reader.
        
        Args:
            filepath: Path to HDF5 or NPZ file
        """
        self.filepath = filepath
        self.data = {}
        self.attrs = {}
        self.qa_data = []
        self.frame_metadata = {}
        
        self._load()
    
    def _load(self):
        """Load dataset from file."""
        if self.filepath.endswith('.h5'):
            self._load_hdf5()
        elif self.filepath.endswith('.npz'):
            self._load_npz()
        else:
            raise ValueError(f"Unsupported format: {self.filepath}")
    
    def _load_hdf5(self):
        """Load HDF5 dataset."""
        import h5py
        
        with h5py.File(self.filepath, 'r') as f:
            # Load main arrays
            for key in f.keys():
                if isinstance(f[key], h5py.Dataset):
                    self.data[key] = f[key][:]
                elif isinstance(f[key], h5py.Group):
                    # Handle groups
                    if key == 'qa_data':
                        # Load QA data
                        qa_grp = f['qa_data']
                        if 'items' in qa_grp:
                            qa_json = qa_grp['items'][()]
                            if isinstance(qa_json, bytes):
                                qa_json = qa_json.decode('utf-8')
                            self.qa_data = json.loads(qa_json)
                    elif key == 'frame_metadata':
                        # Load frame metadata
                        meta_grp = f['frame_metadata']
                        for mkey in meta_grp.keys():
                            self.frame_metadata[mkey] = meta_grp[mkey][:]
            
            # Load attributes
            self.attrs = dict(f.attrs)
    
    def _load_npz(self):
        """Load NPZ dataset."""
        npz_data = np.load(self.filepath, allow_pickle=True)
        for key in npz_data.keys():
            self.data[key] = npz_data[key]
    
    @property
    def num_steps(self) -> int:
        """Total number of steps."""
        if 'observations' in self.data:
            return len(self.data['observations'])
        return 0
    
    @property
    def num_episodes(self) -> int:
        """Total number of episodes."""
        if 'episode_starts' in self.data:
            return len(self.data['episode_starts'])
        return self.attrs.get('total_episodes', 0)
    
    @property
    def obs_dim(self) -> int:
        """Observation dimension."""
        if 'observations' in self.data:
            return self.data['observations'].shape[1]
        return self.attrs.get('obs_dim', 0)
    
    @property
    def action_dim(self) -> int:
        """Action dimension."""
        if 'actions' in self.data:
            return self.data['actions'].shape[1]
        return self.attrs.get('action_dim', 0)
    
    @property
    def mode(self) -> str:
        """Collection mode."""
        return self.attrs.get('mode', 'unknown')
    
    @property
    def has_cost(self) -> bool:
        """Whether dataset has cost information."""
        return 'costs' in self.data
    
    @property
    def has_qa(self) -> bool:
        """Whether dataset has QA data."""
        return len(self.qa_data) > 0
    
    def get_episode_range(self, episode_idx: int) -> Tuple[int, int]:
        """
        Get start and end indices for an episode.
        
        Args:
            episode_idx: Episode index
            
        Returns:
            (start_idx, end_idx) tuple
        """
        if 'episode_starts' not in self.data:
            return 0, self.num_steps
        
        starts = self.data['episode_starts']
        start_idx = starts[episode_idx]
        
        if episode_idx < len(starts) - 1:
            end_idx = starts[episode_idx + 1]
        else:
            end_idx = self.num_steps
        
        return int(start_idx), int(end_idx)
    
    def get_episode_data(self, episode_idx: int) -> Dict[str, np.ndarray]:
        """
        Get data for a specific episode.
        
        Args:
            episode_idx: Episode index
            
        Returns:
            Dictionary with episode data
        """
        start, end = self.get_episode_range(episode_idx)
        
        episode_data = {}
        for key, value in self.data.items():
            if key == 'episode_starts':
                continue
            if isinstance(value, np.ndarray) and len(value) == self.num_steps:
                episode_data[key] = value[start:end]
        
        return episode_data
    
    def get_qa_for_step(self, step_idx: int) -> List[Dict]:
        """Get QA items for a specific step."""
        return [qa for qa in self.qa_data if qa.get('step_index') == step_idx]
    
    def print_info(self):
        """Print dataset information."""
        print("=" * 70)
        print(f"Dataset: {os.path.basename(self.filepath)}")
        print("=" * 70)
        
        # Metadata
        print("\nMetadata:")
        print("-" * 50)
        for key, value in sorted(self.attrs.items()):
            print(f"  {key}: {value}")
        
        # Data arrays
        print("\nData Arrays:")
        print("-" * 50)
        for key, value in sorted(self.data.items()):
            if isinstance(value, np.ndarray):
                dtype_str = str(value.dtype)
                shape_str = str(value.shape)
                if value.size > 0:
                    if np.issubdtype(value.dtype, np.floating):
                        range_str = f"[{value.min():.4f}, {value.max():.4f}], mean={value.mean():.4f}"
                    elif np.issubdtype(value.dtype, np.integer):
                        range_str = f"[{value.min()}, {value.max()}]"
                    elif value.dtype == bool:
                        range_str = f"True: {value.sum()}"
                    else:
                        range_str = ""
                    print(f"  {key}: {shape_str} ({dtype_str}) {range_str}")
                else:
                    print(f"  {key}: {shape_str} ({dtype_str})")
        
        # Frame metadata
        if self.frame_metadata:
            print("\nFrame Metadata:")
            print("-" * 50)
            for key, value in self.frame_metadata.items():
                if isinstance(value, np.ndarray):
                    print(f"  {key}: shape={value.shape}")
        
        # QA data
        if self.qa_data:
            print(f"\nQA Data: {len(self.qa_data)} items")
        
        # Statistics
        print("\nStatistics:")
        print("-" * 50)
        print(f"  Total steps: {self.num_steps}")
        print(f"  Total episodes: {self.num_episodes}")
        if self.num_episodes > 0:
            print(f"  Avg episode length: {self.num_steps / self.num_episodes:.1f}")
        print(f"  Observation dim: {self.obs_dim}")
        print(f"  Action dim: {self.action_dim}")
        
        if 'rewards' in self.data:
            rewards = self.data['rewards']
            print(f"  Total reward: {rewards.sum():.2f}")
            print(f"  Avg reward/step: {rewards.mean():.4f}")
        
        if self.has_cost:
            costs = self.data['costs']
            print(f"  Total cost: {costs.sum():.2f}")
            print(f"  Avg cost/step: {costs.mean():.4f}")
            print(f"  Steps with cost > 0: {(costs > 0).sum()} ({100*(costs > 0).mean():.1f}%)")
    
    def print_samples(self, n_samples: int = 3, start_idx: int = 0):
        """Print sample data points."""
        print("\n" + "=" * 70)
        print(f"Sample Data (steps {start_idx} to {start_idx + n_samples - 1})")
        print("=" * 70)
        
        n = min(n_samples, self.num_steps - start_idx)
        
        for i in range(start_idx, start_idx + n):
            print(f"\n--- Step {i} ---")
            
            # Frame metadata
            if self.frame_metadata:
                if 'is_sample' in self.frame_metadata:
                    is_sample = self.frame_metadata['is_sample'][i]
                    print(f"  Is Sample (keyframe): {is_sample}")
                if 'timestamps' in self.frame_metadata:
                    ts = self.frame_metadata['timestamps'][i]
                    print(f"  Timestamp: {ts / 1e6:.3f}s")
                if 'interpolation_ratios' in self.frame_metadata:
                    ratio = self.frame_metadata['interpolation_ratios'][i]
                    print(f"  Interpolation: {ratio:.2%}")
            
            # Observation
            if 'observations' in self.data:
                obs = self.data['observations'][i]
                print(f"  Observation: shape={obs.shape}")
                # Show first few values
                print(f"    First 10 values: {obs[:10]}")
            
            # Action
            if 'actions' in self.data:
                act = self.data['actions'][i]
                action_dim = self.attrs.get('action_dim', len(act))
                
                # Determine action format
                if action_dim == 40:
                    # 20 waypoints * 2 (x, y)
                    waypoints = act.reshape(-1, 2)
                    print(f"  Action: {len(waypoints)} waypoints (x, y)")
                    print(f"    First: ({waypoints[0, 0]:.2f}, {waypoints[0, 1]:.2f})")
                    print(f"    Last:  ({waypoints[-1, 0]:.2f}, {waypoints[-1, 1]:.2f})")
                elif action_dim % 5 == 0:
                    # Trajectory waypoints * 5 (x, y, vx, vy, heading)
                    n_wp = action_dim // 5
                    waypoints = act.reshape(n_wp, 5)
                    print(f"  Action: {n_wp} waypoints (x, y, vx, vy, heading)")
                    print(f"    First: pos=({waypoints[0, 0]:.2f}, {waypoints[0, 1]:.2f}), "
                          f"vel=({waypoints[0, 2]:.2f}, {waypoints[0, 3]:.2f}), "
                          f"heading={waypoints[0, 4]:.2f}")
                else:
                    print(f"  Action: {act[:10]}...")
            
            # Reward & Cost
            if 'rewards' in self.data:
                print(f"  Reward: {self.data['rewards'][i]:.4f}")
            if 'costs' in self.data:
                print(f"  Cost: {self.data['costs'][i]:.4f}")
            if 'terminals' in self.data:
                print(f"  Terminal: {self.data['terminals'][i]}")
            
            # QA
            qa_items = self.get_qa_for_step(i)
            if qa_items:
                print(f"  QA Items: {len(qa_items)}")
                for qa in qa_items[:2]:
                    q = qa.get('question', '')[:50]
                    a = str(qa.get('answer', ''))[:30]
                    print(f"    Q: {q}...")
                    print(f"    A: {a}")
    
    def print_qa_data(self, max_items: int = 20):
        """Print QA data."""
        if not self.qa_data:
            print("No QA data in this dataset")
            return
        
        print("\n" + "=" * 70)
        print(f"QA Data ({len(self.qa_data)} total items, showing first {min(max_items, len(self.qa_data))})")
        print("=" * 70)
        
        for i, qa in enumerate(self.qa_data[:max_items]):
            print(f"\n--- QA Item {i} ---")
            print(f"  Step: {qa.get('step_index', 'N/A')}")
            print(f"  Scene: {qa.get('scene', 'N/A')}")
            print(f"  Sample Index: {qa.get('sample_index', 'N/A')}")
            print(f"  Template Type: {qa.get('template_type', qa.get('question_type', 'N/A'))}")
            print(f"  Question: {qa.get('question', 'N/A')}")
            print(f"  Answer: {qa.get('answer', 'N/A')}")
        
        if len(self.qa_data) > max_items:
            print(f"\n... and {len(self.qa_data) - max_items} more QA items")
    
    def visualize_episode(self, episode_idx: int = 0, save_path: Optional[str] = None):
        """
        Visualize an episode's trajectory.
        
        Args:
            episode_idx: Episode index to visualize
            save_path: Optional path to save the figure
        """
        try:
            import matplotlib.pyplot as plt
        except ImportError:
            print("Error: matplotlib required for visualization")
            print("Install with: pip install matplotlib")
            return
        
        if episode_idx >= self.num_episodes:
            print(f"Error: Episode {episode_idx} not found (max: {self.num_episodes - 1})")
            return
        
        episode_data = self.get_episode_data(episode_idx)
        start, end = self.get_episode_range(episode_idx)
        
        print(f"\nVisualizing Episode {episode_idx} (steps {start}-{end-1})")
        
        # Extract trajectory from actions
        actions = episode_data.get('actions', np.array([]))
        if len(actions) == 0:
            print("No action data to visualize")
            return
        
        # Determine action format
        action_dim = actions.shape[1]
        
        fig, axes = plt.subplots(2, 2, figsize=(14, 12))
        
        # === Plot 1: Trajectory visualization ===
        ax1 = axes[0, 0]
        
        # Accumulate ego positions from actions
        ego_positions = [[0, 0]]
        
        for i, act in enumerate(actions):
            if action_dim == 40:
                # 20 waypoints * 2
                waypoints = act.reshape(-1, 2)
            elif action_dim % 5 == 0:
                # n waypoints * 5
                waypoints = act.reshape(-1, 5)[:, :2]
            else:
                continue
            
            # Use first waypoint as next position
            if len(waypoints) > 0:
                # Waypoints are relative to current position
                # For visualization, we accumulate
                if i == 0:
                    ego_positions.append([waypoints[0, 0], waypoints[0, 1]])
                else:
                    last_pos = ego_positions[-1]
                    ego_positions.append([
                        last_pos[0] + waypoints[0, 0] * 0.1,  # Scale for visibility
                        last_pos[1] + waypoints[0, 1] * 0.1
                    ])
        
        ego_positions = np.array(ego_positions)
        
        # Plot trajectory
        ax1.plot(ego_positions[:, 0], ego_positions[:, 1], 'b-', linewidth=1.5, label='Ego trajectory')
        ax1.scatter(ego_positions[0, 0], ego_positions[0, 1], c='green', s=100, marker='o', label='Start', zorder=5)
        ax1.scatter(ego_positions[-1, 0], ego_positions[-1, 1], c='red', s=100, marker='s', label='End', zorder=5)
        
        # Mark samples if metadata available
        if self.frame_metadata and 'is_sample' in self.frame_metadata:
            is_sample = self.frame_metadata['is_sample'][start:end]
            sample_indices = np.where(is_sample)[0]
            if len(sample_indices) > 0 and len(sample_indices) < len(ego_positions):
                ax1.scatter(ego_positions[sample_indices, 0], ego_positions[sample_indices, 1],
                           c='orange', s=50, marker='^', label='Samples', zorder=4)
        
        ax1.set_xlabel('X Position')
        ax1.set_ylabel('Y Position')
        ax1.set_title(f'Episode {episode_idx} Trajectory')
        ax1.legend()
        ax1.axis('equal')
        ax1.grid(True, alpha=0.3)
        
        # === Plot 2: Rewards over time ===
        ax2 = axes[0, 1]
        
        if 'rewards' in episode_data:
            rewards = episode_data['rewards']
            steps = np.arange(len(rewards))
            ax2.plot(steps, rewards, 'b-', linewidth=1)
            ax2.fill_between(steps, 0, rewards, alpha=0.3)
            ax2.axhline(y=0, color='gray', linestyle='--', linewidth=0.5)
            ax2.set_xlabel('Step')
            ax2.set_ylabel('Reward')
            ax2.set_title('Rewards')
            ax2.grid(True, alpha=0.3)
        else:
            ax2.text(0.5, 0.5, 'No reward data', ha='center', va='center', transform=ax2.transAxes)
        
        # === Plot 3: Costs over time ===
        ax3 = axes[1, 0]
        
        if 'costs' in episode_data:
            costs = episode_data['costs']
            steps = np.arange(len(costs))
            ax3.plot(steps, costs, 'r-', linewidth=1)
            ax3.fill_between(steps, 0, costs, alpha=0.3, color='red')
            ax3.axhline(y=0, color='gray', linestyle='--', linewidth=0.5)
            ax3.set_xlabel('Step')
            ax3.set_ylabel('Cost')
            ax3.set_title('Costs (CMDP)')
            ax3.grid(True, alpha=0.3)
        else:
            ax3.text(0.5, 0.5, 'No cost data (MDP mode)', ha='center', va='center', transform=ax3.transAxes)
        
        # === Plot 4: Action magnitudes ===
        ax4 = axes[1, 1]
        
        if action_dim == 40:
            # 20 waypoints * 2
            waypoints_all = actions.reshape(len(actions), -1, 2)
            # Compute displacement magnitude for each step
            displacements = np.linalg.norm(waypoints_all[:, -1, :], axis=1)  # Last waypoint distance
        elif action_dim % 5 == 0:
            n_wp = action_dim // 5
            waypoints_all = actions.reshape(len(actions), n_wp, 5)
            displacements = np.linalg.norm(waypoints_all[:, -1, :2], axis=1)
        else:
            displacements = np.linalg.norm(actions, axis=1)
        
        steps = np.arange(len(displacements))
        ax4.plot(steps, displacements, 'g-', linewidth=1)
        ax4.fill_between(steps, 0, displacements, alpha=0.3, color='green')
        ax4.set_xlabel('Step')
        ax4.set_ylabel('Trajectory Length')
        ax4.set_title('Action Trajectory Magnitude')
        ax4.grid(True, alpha=0.3)
        
        plt.tight_layout()
        
        if save_path:
            plt.savefig(save_path, dpi=150, bbox_inches='tight')
            print(f"Saved visualization to: {save_path}")
        else:
            plt.show()
    
    def visualize_observation_distribution(self, save_path: Optional[str] = None):
        """Visualize observation distribution."""
        try:
            import matplotlib.pyplot as plt
        except ImportError:
            print("Error: matplotlib required for visualization")
            return
        
        if 'observations' not in self.data:
            print("No observation data")
            return
        
        obs = self.data['observations']
        
        fig, axes = plt.subplots(2, 2, figsize=(14, 10))
        
        # === Plot 1: Observation statistics per dimension ===
        ax1 = axes[0, 0]
        
        means = obs.mean(axis=0)
        stds = obs.std(axis=0)
        dims = np.arange(len(means))
        
        ax1.bar(dims, means, alpha=0.7, label='Mean')
        ax1.errorbar(dims, means, yerr=stds, fmt='none', color='red', capsize=1, label='Std')
        ax1.set_xlabel('Dimension')
        ax1.set_ylabel('Value')
        ax1.set_title('Observation Statistics per Dimension')
        ax1.legend()
        
        # === Plot 2: Observation correlation heatmap (subset) ===
        ax2 = axes[0, 1]
        
        n_dims = min(20, obs.shape[1])  # Limit for visibility
        corr = np.corrcoef(obs[:, :n_dims].T)
        
        im = ax2.imshow(corr, cmap='coolwarm', aspect='auto', vmin=-1, vmax=1)
        ax2.set_xlabel('Dimension')
        ax2.set_ylabel('Dimension')
        ax2.set_title(f'Observation Correlation (first {n_dims} dims)')
        plt.colorbar(im, ax=ax2)
        
        # === Plot 3: Observation histogram (selected dimensions) ===
        ax3 = axes[1, 0]
        
        # First 5 dimensions
        for i in range(min(5, obs.shape[1])):
            ax3.hist(obs[:, i], bins=50, alpha=0.5, label=f'Dim {i}')
        ax3.set_xlabel('Value')
        ax3.set_ylabel('Count')
        ax3.set_title('Observation Distribution (first 5 dims)')
        ax3.legend()
        
        # === Plot 4: Action histogram ===
        ax4 = axes[1, 1]
        
        if 'actions' in self.data:
            act = self.data['actions']
            for i in range(min(3, act.shape[1])):
                ax4.hist(act[:, i], bins=50, alpha=0.5, label=f'Dim {i}')
            ax4.set_xlabel('Value')
            ax4.set_ylabel('Count')
            ax4.set_title('Action Distribution (first 3 dims)')
            ax4.legend()
        else:
            ax4.text(0.5, 0.5, 'No action data', ha='center', va='center', transform=ax4.transAxes)
        
        plt.tight_layout()
        
        if save_path:
            plt.savefig(save_path, dpi=150, bbox_inches='tight')
            print(f"Saved visualization to: {save_path}")
        else:
            plt.show()


def list_datasets(output_dir: str) -> List[str]:
    """List available datasets."""
    print("=" * 70)
    print(f"Available datasets in: {output_dir}")
    print("=" * 70)
    
    if not os.path.exists(output_dir):
        print("  (directory does not exist)")
        return []
    
    files = []
    for f in os.listdir(output_dir):
        if f.endswith('.h5') or f.endswith('.npz'):
            filepath = os.path.join(output_dir, f)
            size = os.path.getsize(filepath) / 1024  # KB
            files.append((f, size))
    
    if not files:
        print("  (no datasets found)")
        return []
    
    for f, size in sorted(files):
        if size > 1024:
            print(f"  {f} ({size/1024:.1f} MB)")
        else:
            print(f"  {f} ({size:.1f} KB)")
    
    return [f[0] for f in files]


def resolve_filepath(filepath: str) -> Optional[str]:
    """Resolve filepath to absolute path."""
    if os.path.isabs(filepath):
        return filepath if os.path.exists(filepath) else None
    
    # Try relative to project root
    path = os.path.join(project_root, filepath)
    if os.path.exists(path):
        return path
    
    # Try relative to DEFAULT_OUTPUT_DIR
    path = os.path.join(DEFAULT_OUTPUT_DIR, filepath)
    if os.path.exists(path):
        return path
    
    # Try current directory
    if os.path.exists(filepath):
        return os.path.abspath(filepath)
    
    return None


def parse_args():
    parser = argparse.ArgumentParser(
        description="Read and visualize offline RL datasets",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  # Show dataset info
  python -m meta_qa.scripts.data_collect.read_data --file data.h5
  
  # List available datasets
  python -m meta_qa.scripts.data_collect.read_data --list
  
  # Visualize episode trajectory
  python -m meta_qa.scripts.data_collect.read_data --file data.h5 --visualize --episode 0
  
  # Show QA data
  python -m meta_qa.scripts.data_collect.read_data --file data.h5 --show_qa
  
  # Visualize and save figure
  python -m meta_qa.scripts.data_collect.read_data --file data.h5 --visualize --save_fig output.png
"""
    )
    
    parser.add_argument("--file", "-f", type=str, default=None,
                       help="Dataset file path (absolute or relative)")
    parser.add_argument("--list", "-l", action="store_true",
                       help="List available datasets")
    parser.add_argument("--samples", "-s", type=int, default=3,
                       help="Number of sample data points to show")
    parser.add_argument("--start", type=int, default=0,
                       help="Starting index for samples")
    parser.add_argument("--show_qa", action="store_true",
                       help="Show QA data")
    parser.add_argument("--max_qa", type=int, default=20,
                       help="Maximum QA items to show")
    parser.add_argument("--visualize", "-v", action="store_true",
                       help="Visualize episode trajectory")
    parser.add_argument("--visualize_dist", action="store_true",
                       help="Visualize observation/action distribution")
    parser.add_argument("--episode", "-e", type=int, default=0,
                       help="Episode index to visualize")
    parser.add_argument("--save_fig", type=str, default=None,
                       help="Save visualization to file")
    parser.add_argument("--no_info", action="store_true",
                       help="Skip dataset info printing")
    
    return parser.parse_args()


def main():
    args = parse_args()
    
    # List datasets
    if args.list or args.file is None:
        files = list_datasets(DEFAULT_OUTPUT_DIR)
        if args.file is None and files:
            print(f"\nUse --file <filename> to inspect a dataset")
        if args.file is None:
            return
    
    # Resolve file path
    filepath = resolve_filepath(args.file)
    if filepath is None:
        print(f"Error: File not found: {args.file}")
        print(f"  Tried:")
        print(f"    - {args.file}")
        print(f"    - {os.path.join(project_root, args.file)}")
        print(f"    - {os.path.join(DEFAULT_OUTPUT_DIR, args.file)}")
        return
    
    print(f"\nLoading: {filepath}\n")
    
    try:
        reader = OfflineDataReader(filepath)
    except Exception as e:
        print(f"Error loading dataset: {e}")
        import traceback
        traceback.print_exc()
        return
    
    # Print info
    if not args.no_info:
        reader.print_info()
    
    # Print samples
    if args.samples > 0 and not args.no_info:
        reader.print_samples(n_samples=args.samples, start_idx=args.start)
    
    # Show QA data
    if args.show_qa:
        reader.print_qa_data(max_items=args.max_qa)
    
    # Visualize trajectory
    if args.visualize:
        reader.visualize_episode(episode_idx=args.episode, save_path=args.save_fig)
    
    # Visualize distribution
    if args.visualize_dist:
        save_path = args.save_fig
        if save_path and args.visualize:
            # Different filename for distribution plot
            base, ext = os.path.splitext(save_path)
            save_path = f"{base}_dist{ext}"
        reader.visualize_observation_distribution(save_path=save_path)
    
    print("\nDone!")


if __name__ == "__main__":
    main()
